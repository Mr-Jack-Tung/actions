# Logs generated by the Action Server

The Action Server has 2 different log "scopes":

1. Logs from running the `Action Server` itself.
2. Logs from running an `@action`.

## 1. Logs from running the `Action Server` itself.

The logs from the `Action Server` itself are stored inside the datadir and they're
generated using the standard Python logging.

Note: it's using a `RotatingFileHandler` with `maxBytes=1_000_000` and `backupCount=3`.

Note: passing the `--verbose` when calling `action-server start` will increase the amount of information logged.

When the `Action Server` is started it'll print the logs location to the `stdout`
with a message such as:

`Logs may be found at: <datadir>\server_log.txt`

## 2. Logs from running an `Action`

When an `@action` is run, run artifacts are commonly generated with information
related to the run and it's possible to collect such artifacts.

Whenever a `POST` is done to run an `Action`, the response to that `POST` will
include a header named `X-Action-Server-Run-Id`. Using this header allows for
further introspection on that run.

To know about which artifacts were generated from a run it's possible to `GET`:

`/api/runs/{run_id}/artifacts`

Artifacts usually generated:

- `__action_server_output.txt`: contains the output generated when running the action

- `log.html`: the log output for running the action

To actually get an artifact it's possible to `GET`:

- `/api/runs/${runId}/artifacts/text-content`

- `/api/runs/${runId}/artifacts/binary-content`

Note that the `log.html` has a special handler for it so that it's
possible to `GET` it from:

`/api/runs/${runId}/log.html`

Hint: you can get the `openapi.json` spec with the full API provided by the action
server by starting the action server with the `--full-openapi-spec` flag to
verify the parameters requested in each case (also, accessing `http://<action-server-url>/docs`
provides a way to manually run custom requests against the action server based on
the `openapi.json`).

Hint: if you have a `log.html` it's usually possible to actually get the decoded contents
of that log (as an iterator of dicts) in Python by using the `robocorp.log` library directly by
calling: `robocorp.log.iter_decoded_log_format_from_log_html(path_to_log_html)` (an internal
implementation of that is also used in typescript in the `log.html` itself to show the logs).

## Customizing the `log.html` contents for an `Action Package`

`sema4ai.actions` will use `robocorp.log` to generate logs. `Action` authors may
customize what's actually logged though.

By default, logging is generated for all user code executed and calls into
libraries in site-packages and python libs (which by default are configured to
show just when called from user code and will not show internal calls inside the
library itself).

It's possible to change how libraries or user code is logged by customizing
`log_filter_rules` by creating a `[tool.robocorp.log]` in `pyproject.toml`.

There are three different logging configurations that may be applied for each module:

- `exclude`: excludes a module from logging.
- `full_log` (default for user code): logs a module with full information, such as method calls, arguments, yields, local assigns, and more.
- `log_on_project_call` (default for library code -- since 2.0): logs only method calls, arguments, return values and exceptions, but only when a library method is called from user code. This configuration is meant to be used for libraries (modules in site-packages or python lib) logging.

Example showing how to exclude from logging any user module which ends with `producer`:

```
[tool.robocorp.log]

log_filter_rules = [
    {name = "*producer", kind = "exclude"},
]
```

By default libraries in site-packages and python lib will be configured as `log_on_project_call`, but
it's possible to change its default through `default_library_filter_kind`.

Example of `pyproject.toml` where the `rpaframework` and `selenium`
libraries are configured to be logged and all other libraries in site-packages/python lib are
excluded by default:

```
[tool.robocorp.log]

log_filter_rules = [
    {name = "RPA", kind = "log_on_project_call"},
    {name = "selenium", kind = "log_on_project_call"},
    {name = "SeleniumLibrary", kind = "log_on_project_call"},
]

default_library_filter_kind = "exclude"
```

Note that when specifying a module name to match in `log_filter_rules`,
the name may either match exactly or the module name must start with the
name followed by a dot.

This means that, for example, `RPA` would match `RPA.Browser`,
but not `RPAmodule` nor `another.RPA`.

As of `robocorp-tasks 2.0`, it's also possible to use `fnmatch` style names
(where `*` matches anything and `?` matches any single char -- see: https://docs.python.org/3/library/fnmatch.html for more information).

i.e.:

```
[tool.robocorp.log]

log_filter_rules = [
    {name = "proj.*", kind = "full_log"},
    {name = "proj[AB]", kind = "full_log"},
]
```

Note that the order of the rules is important as rules which appear
first are matched before the ones that appear afterwards.
